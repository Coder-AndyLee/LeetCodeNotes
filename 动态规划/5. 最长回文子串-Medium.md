# [Description](https://leetcode-cn.com/problems/longest-palindromic-substring)
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：
```python
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```
示例 2：
```python
输入: "cbbd"
输出: "bb"
```


# Solution
### 解法一：动态规划
- 抓住主要状态转移方程
	```python
	if s[i] == s[j] and dp[i+1][j-1] == 1:
		dp[i][j] = 1
	```
- 本题遍历dp的思路与常规套路不太一样，因为状态转移是从短子串向长子串转移的，所以遍历应按**子串长度**进行。
- 初始条件：长度为1，以及长度为2且两字符相等的子串为回文子串
	```python
	for i in range(len(s)):
		dp[i][i] = 1
		if i+1 < len(s) and s[i] == s[i+1]:
			dp[i][i+1] = 1
	```
- 注意考虑边界条件：**字符串为空**或为**长度为1**
- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n^2)$
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if s == '':
            return ''
        elif len(s) == 1:
            return s
        
        dp = [[0]*len(s) for _ in range(len(s))]
        start = 0
        max_len = 1
        
        for i in range(len(s)):
            dp[i][i] = 1
            if i+1 < len(s) and s[i] == s[i+1]:
                dp[i][i+1] = 1
                start = i
                max_len = 2
                
        for length in range(3, len(s)+1):
            for i in range(len(s) - length + 1):
                j = i + length - 1
                if s[i] == s[j] and dp[i+1][j-1] == 1:
                    dp[i][j] = 1
                    start = i
                    max_len = length
        # print(start, start+max_len+1)
        return s[start : start+max_len]
```

### 解法二：中心扩散
- 遍历字符串，找 以i为中点 / 或以i,i+1为中点 的最长回文子串长度，并更新记录值。
- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def spread(s, left, right):
            while left >= 0 and right <= len(s)-1 and s[left] == s[right]:
                left -= 1
                right += 1
            return left+1, right-1

        start, end = 0, 0

        for i in range(len(s)):
            l1, r1 = spread(s, i, i)
            l2, r2 = spread(s, i, i+1)
            if r1 - l1 > end - start:
                start, end = l1, r1
            if r2 - l2 > end - start:
                start, end = l2, r2
            
        return s[start: end+1]
```